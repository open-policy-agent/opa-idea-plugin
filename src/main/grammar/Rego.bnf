{
  parserClass="org.opa.ideaplugin.lang.parser.RegoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Rego"
  psiImplClassSuffix="Impl"
  psiPackage= "org.opa.ideaplugin.lang.psi"
  psiImplPackage="org.opa.ideaplugin.lang.psi.impl"

  elementTypeHolderClass="org.opa.ideaplugin.lang.psi.RegoTypes"
  elementTypeClass="org.opa.ideaplugin.lang.psi.RegoElementType"
  tokenTypeClass="org.opa.ideaplugin.lang.psi.RegoTokenType"

   tokens = [
       // literals

       TRUE_KW = 'true'
       FALSE_KW = 'false'
       NULL_KW = 'null'
       PACKAGE_KW = 'package'
       IMPORT_KW = 'import'
       AS_KW = 'as'
       DEFAULT_KW = 'default'
       ELSE_KW = 'else'
       NOT_KW = 'not'
       WITH_KW = 'with'
       SOME_KW = 'some'

       // operators
       ASSIGN = ':='
       UNIFY = '='
       OR = '|'
       AND = '&'
       PLUS = '+'
       MINUS = '-'
       MULTIPLY = '*'
       DIVIDE = '/'
       REMAINDER = '%'

       EQ = '=='
       NEQ = '!='
       LT = '<'
       GT = '>'
       LTE = '<='
       GTE = '>='

       // parentheses
       LPAREN = '('
       RPAREN = ')'
       LBRACE = '{'
       RBRACE = '}'
       LBRACK = '['
       RBRACK = ']'

       // other
       SET_KW = 'set'
       COMMA = ','
       SEMIC = ';'
       COLON = ':'
       BACKTICK = '`'
       DOT = '.'
       UNDER = '_'

       STRING_LITERAL = 'regexp:("[^"\\]*(\\.[^"\\]*)*")|(`[^`]*`)'
       NUMBER = "regexp:-?(0|([1-9][0-9]*))(\.[0-9]+)?([eE][+-]?[0-9]+)?"
       COMMENT = "regexp:#.*"
       VAR = "regexp:[\p{Alpha}_][\p{Alnum}_]*"
       SPACE "regexp:[\s]"
   ]

}

root                ::= package import* policy

package             ::= PACKAGE_KW ref
import              ::= IMPORT_KW ref ( AS_KW  VAR)?
policy              ::= rule*
rule                ::= DEFAULT_KW? rule-head rule-body*
rule-head           ::= object-assign | assignment | function | parametrization | simple

//Head types
function            ::= function-head (assignment-operator function-body)?
function-head       ::= rule-name (empty-function | args-function)
args-function       ::= LPAREN !RPAREN rule-args? RPAREN
empty-function      ::= LPAREN RPAREN
function-body       ::= assignment | assignment-body | (calculation? ref-arg*)

parametrization     ::= calculation? ref-arg* rule-name ( LBRACK object-body ( COMMA object-body )* RBRACK )
assignment          ::= rule-name assignment-operator assignment-body with-modifier?
simple              ::= rule-name
object-assign       ::= rule-name UNIFY assignment-body? object
rule-name           ::= ref | array-type | UNDER

calculation         ::= LPAREN? calc-operation+ RPAREN?
calc-operation      ::= calc-arg (arith-operator calc-arg)+
calc-arg            ::= LPAREN? (ref | NUMBER) RPAREN?

rule-args           ::= assignment-body ( COMMA assignment-body )*
rule-body           ::= (ELSE_KW ( UNIFY assignment-body )? )? object

some-decl           ::= SOME_KW VAR ( COMMA VAR )*
object              ::= LBRACE object-body? RBRACE
object-body         ::= ( assignment | object-item | condition | standalone | negation | rule-body | SEMIC | COMMA)*
object-item         ::= scalar COLON? assignment-body?
assignment-body     ::= function | calculation | object | standalone | scalar | ref

standalone          ::= some-decl | comprehension | comprehension-head | array-type | set-type

negation            ::= NOT_KW? (function | ref)
ref                 ::= VAR ref-arg*
scalar              ::= STRING_LITERAL | NUMBER | TRUE_KW | FALSE_KW | NULL_KW | UNDER
comprehension       ::= LBRACK comprehension-head comprehension-body* RBRACK
comprehension-head  ::= ref (COLON ref)? OR ((condition | assignment | some-decl) SEMIC)?
comprehension-body  ::= (assignment | condition) SEMIC?

array-type          ::= LBRACK array-body RBRACK
array-body          ::= (assignment-body | rule-body)? (COMMA (assignment-body | rule-body)?)*
set-type            ::= LBRACE (assignment-body | rule-body)? (COMMA (assignment-body | rule-body))* RBRACE
ref-arg             ::= ref-arg-dot | ref-arg-brack
ref-arg-brack       ::= LBRACK ( scalar | VAR | UNDER | DOT )* RBRACK
ref-arg-dot         ::= DOT (function-head | VAR)


condition           ::= NOT_KW? expr infix-operator expr
with-modifier       ::= WITH_KW assignment-body AS_KW assignment-body
expr                ::= assignment-body with-modifier?
infix-operator      ::= bool-operator | bin-operator
bool-operator       ::= "==" | "!=" | "<" | ">" | ">=" | "<="
arith-operator      ::= "+" | "-" | "*" | "/"
bin-operator        ::= "&" | "|"
assignment-operator ::= ":=" | "="
